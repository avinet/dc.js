<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>dc.js Source: chart-ext/dcextended.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">dc.js</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="dc.html">dc</a></li><li><a href="dc.chartRegistry.html">dc.chartRegistry</a></li><li><a href="dc.filters.html">dc.filters</a></li><li><a href="dc.printers.html">dc.printers</a></li><li><a href="dc.units.html">dc.units</a></li><li><a href="dc.units.fp.html">dc.units.fp</a></li><li><a href="dc.utils.html">dc.utils</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="dc.barChart.html">dc.barChart</a></li><li><a href="dc.boxPlot.html">dc.boxPlot</a></li><li><a href="dc.bubbleChart.html">dc.bubbleChart</a></li><li><a href="dc.bubbleOverlay.html">dc.bubbleOverlay</a></li><li><a href="dc.cboxMenu.html">dc.cboxMenu</a></li><li><a href="dc.compositeChart.html">dc.compositeChart</a></li><li><a href="dc.config.html">dc.config</a></li><li><a href="dc.dataCount.html">dc.dataCount</a></li><li><a href="dc.dataGrid.html">dc.dataGrid</a></li><li><a href="dc.dataTable.html">dc.dataTable</a></li><li><a href="dc.filters.HierarchyFilter.html">dc.filters.HierarchyFilter</a></li><li><a href="dc.filters.RangedFilter.html">dc.filters.RangedFilter</a></li><li><a href="dc.filters.RangedTwoDimensionalFilter.html">dc.filters.RangedTwoDimensionalFilter</a></li><li><a href="dc.filters.TwoDimensionalFilter.html">dc.filters.TwoDimensionalFilter</a></li><li><a href="dc.geoChoroplethChart.html">dc.geoChoroplethChart</a></li><li><a href="dc.heatMap.html">dc.heatMap</a></li><li><a href="dc.htmlLegend.html">dc.htmlLegend</a></li><li><a href="dc.legend.html">dc.legend</a></li><li><a href="dc.lineChart.html">dc.lineChart</a></li><li><a href="dc.logger.html">dc.logger</a></li><li><a href="dc.numberDisplay.html">dc.numberDisplay</a></li><li><a href="dc.pieChart.html">dc.pieChart</a></li><li><a href="dc.rowChart.html">dc.rowChart</a></li><li><a href="dc.scatterPlot.html">dc.scatterPlot</a></li><li><a href="dc.selectMenu.html">dc.selectMenu</a></li><li><a href="dc.seriesChart.html">dc.seriesChart</a></li><li><a href="dc.sunburstChart.html">dc.sunburstChart</a></li><li><a href="dc.textFilterWidget.html">dc.textFilterWidget</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="mixins.list.html" class="dropdown-toggle" data-toggle="dropdown">Mixins<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="dc.baseMixin.html">dc.baseMixin</a></li><li><a href="dc.bubbleMixin.html">dc.bubbleMixin</a></li><li><a href="dc.capMixin.html">dc.capMixin</a></li><li><a href="dc.colorMixin.html">dc.colorMixin</a></li><li><a href="dc.coordinateGridMixin.html">dc.coordinateGridMixin</a></li><li><a href="dc.marginMixin.html">dc.marginMixin</a></li><li><a href="dc.stackMixin.html">dc.stackMixin</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#groupedBarChart">groupedBarChart</a></li><li><a href="global.html#groupedRowChart">groupedRowChart</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: chart-ext/dcextended.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">dc.barChartOrdinal = function (parent, chartGroup) {
    var _chart = dc.marginMixin(dc.baseMixin({}));
    var _g;
    var xScale;
    var yScale;
    var _xAxisLabel;
    var _yAxisLabel;
    var _colors;
  
    // Set standard margins
    _chart.margins().top = 20;
    _chart.margins().right = 20;
    _chart.margins().bottom = 40;
    _chart.margins().left = 40;
  
    var buildOut = function () {
        var offsets = {};
        return function (d, y0, y) {
            var current = offsets[d.x];
            if (!current) {
                current = [0, 0];
            }
            if (y >= 0) {
                d.y0 = current[0];
                d.y = y;
                current[0] += y;
            } else {
                d.y0 = current[1] + y;
                d.y = y;
                current[1] += y;
            }
  
            offsets[d.x] = current;
        };
    };
  
    _chart.colors = function (colors) {
        _colors = colors;
        return _chart;
    };
  
    _chart.data(function (group) {
        var dataset = group.map(function (d) {
            return d.key[1].map(function (o, i) {
                // Structure it so that your numeric
                // axis (the stacked amount) is y
                return {
                    x: o.title,
                    y: o.value,
                    z: d.key[0]
                };
            });
        });
        var stack = d3.layout.stack().out(buildOut());
  
        stack(dataset);
  
        dataset = dataset.map(function (group) {
            return group.map(function (d) {
                // Invert the x and y values, and y0 becomes x0
                return {
                    x: d.y,
                    y: d.x,
                    x0: d.y0,
                    z: d.z
                };
            });
        });
  
        return dataset;
    });
  
    _chart.label(function (d) {
        return dc.utils.printSingleValue(d.x0 + d.x);
    }, false);
  
    _chart._doRender = function () {
        _chart.resetSvg();
        _g = _chart.svg();
        drawChart();
        return _chart;
    };
  
    _chart._doRedraw = function () {
        var data = _chart.data();
        updateValues(data);
        return _chart;
    };
  
    _chart.xAxisLabel = function (title) {
        _xAxisLabel = title;
        return _chart;
    };
  
    _chart.yAxisLabel = function (title) {
        _yAxisLabel = title;
        return _chart;
    };
  
    function updateValues (_chartData) {
        var _chartHeight = _chart.height() - _chart.margins().top - _chart.margins().bottom;
  
        _g.selectAll('rect')
              .transition()
              .duration(_chart.transitionDuration())
              .attr('y', function (d) {
                  return yScale(d.x0 + Math.abs(d.x));
              })
              .attr('height', function (d) {
                  return yScale(d.x0) - yScale(d.x0 + Math.abs(d.x));
              });
  
        // move x-axis text to the bottom of the chart
        _g
              .selectAll('.x.axis text')
              .attr('dy', _chartHeight - yScale(0));
    }
  
    function drawChart () {
        // Get your data
        var data = _chart.data();
        var margins = _chart.margins();
        var height = _chart.height();
        var width = _chart.width();
        var _colorScale = _colors;
        var _chartWidth = _chart.width() - _chart.margins().left - _chart.margins().right;
        var _chartHeight = _chart.height() - _chart.margins().top - _chart.margins().bottom;
  
        _chart.title(function (d) {
            return d.z;
        });
  
        // Put all drawing methods here
        var _chartArea = _g
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', 'translate(' + margins.left + ',' + margins.top + ')');
  
        var xMin = d3.min(data, function (group) {
            return d3.min(group, function (d) {
                return d.x0;
            });
        });
        var xMax = d3.max(data, function (group) {
            return d3.max(group, function (d) {
                return d.x + d.x0;
            });
        });
        var domain = data[0].map(function (d) {
            return d.y;
        });
  
        yScale = d3.scale.linear()
        .domain([xMax, xMin])
        .range([0, height - margins.top - margins.bottom]);
        xScale = d3.scale.ordinal()
        .domain(domain)
        .rangeRoundBands([0, width - margins.left - margins.right], 0.1);
  
        var xAxis = d3.svg.axis()
        .scale(xScale)
        .orient('bottom');
        var yAxis = d3.svg.axis()
        .scale(yScale)
        .orient('left');
  
        var chartGroup = _chartArea.selectAll('.chartGroup')
        .data(data)
        .enter()
        .append('g');
  
        chartGroup.selectAll('rect')
        .data(function (d) {
            return d;
        })
        .enter()
        .append('rect')
        .style('fill', function (d) {
            return _colorScale(d.z);
        })
        .attr('y', function (d) {
            return yScale(0);
        })
        .attr('x', function (d, i) {
            return xScale(d.y);
        })
        .attr('width', function (d) {
            return xScale.rangeBand();
        })
        .attr('height', function (d) {
            return 0;
        })
        .append('svg:title').text(function (d) {
            return d.z + ': ' + d.x;
        });
  
        // X axis title
        _chartArea.append('g')
        .attr('class', 'x-axis-label x-label')
        .append('text')
        .attr('x', -_chart.margins().right + (_chartWidth / 2))
        .attr('y', _chartHeight + _chart.margins().bottom - 10)
        .text(_xAxisLabel);
  
        // Y axis title
        _chartArea.append('g')
        .attr('class', 'y-axis-label y-label')
        .append('text')
        .attr('x', -(_chartHeight / 2))
        .attr('y', -_chart.margins().left + 15)
        .attr('transform', 'rotate(-90)')
        .text(_yAxisLabel);
  
        // Add axis
        _chartArea.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + yScale(0) + ')')
        .call(xAxis);
  
        _chartArea.append('g')
        .attr('class', 'y axis')
        .call(yAxis)
        .selectAll('text')
        .attr('dy', '0.1em')
        .style('text-anchor', 'end');
  
        updateValues(data);
    }
  
    return _chart.anchor(parent, chartGroup);
};
  
/**
   * Concrete grouped bar chart implementation.
   *
   * @name groupedBarChart
   * @param {String|node|d3.selection} parent - Any valid
   * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
   * @return {dc.groupedBarChart}
   */
dc.groupedBarChart = function (parent, chartGroup) {
    var _g;
  
    var _width = 100;
    var _height = 100;
  
    var _chartWidth = _width;
    var _chartHeight = _height;
  
    var _chart = dc.marginMixin(dc.baseMixin({}));
  
    // Set standard margins
    _chart.margins().top = 20;
    _chart.margins().right = 20;
    _chart.margins().bottom = 40;
    _chart.margins().left = 40;
  
    var _valueLabelFormat = d3.format(',.0f');
    var _yAxisLabelFormat = d3.format(',.0f');
    var _xAxisLabel;
    var _yAxisLabel;
    var _yAxisMinValue = 0;
    var _yAxisMaxValue;
    var _chartArea;
    var _chartData;
    var _groupNames;
    var _yScale;
    var _colors;
    var _highlightVariables = [];
    var _highlightColor = '#ff0000';
  
    _chart.highlightColor = function (highlightColor) {
        _highlightColor = highlightColor;
        return _chart;
    };
  
    _chart.highlightVariables = function (highlightVariables) {
        _highlightVariables = highlightVariables;
        return _chart;
    };
  
    var _seriesSort = function (d) {
        return d;
    };
  
    _chart.colors = function (colorFunction) {
        if (typeof colorFunction === 'function') {
            _colors = colorFunction;
        }
        return _chart;
    };
  
    _chart.yAxisLabelFormat = function (labelFmt) {
        if (labelFmt !== undefined) {
            _yAxisLabelFormat = labelFmt;
        } else {
            return _yAxisLabelFormat;
        }
        return _chart;
    };
  
    _chart.yAxisMinValue = function (value) {
        if (value) {
            _yAxisMinValue = value;
        }
        return _chart;
    };
  
    _chart.yAxisMaxValue = function (value) {
        if (value) {
            _yAxisMaxValue = value;
        }
        return _chart;
    };
  
    var _valueAccessor = function (d) {
        return d.value;
    };
  
    _chart.valueAccessor = function (valueAccessor) {
        if (valueAccessor === undefined) {
            return _valueAccessor;
        } else {
            _valueAccessor = valueAccessor;
        }
        return _chart;
    };
  
    _chart.width = function (width) {
        if (width === undefined) {
            return _width;
        } else {
            _width = width;
        }
        return _chart;
    };
  
    _chart.height = function (height) {
        if (height === undefined) {
            return _height;
        } else {
            _height = height;
        }
        return _chart;
    };
  
    _chart.xAxisLabel = function (title) {
        _xAxisLabel = title;
        return _chart;
    };
  
    _chart.yAxisLabel = function (title) {
        _yAxisLabel = title;
        return _chart;
    };
  
    _chart.seriesSort = function (seriesSort) {
        if (typeof seriesSort === 'function') {
            _seriesSort = seriesSort;
        } else {
            return _seriesSort;
        }
    };
  
    _chart.parseGroup = function (inputGroup) {
        var tmpObj = {};
        var keys = [];
        var subKeys = [];
        var _data = [];
  
        inputGroup.all()
              .map(function (d) {
                  if (keys.indexOf(d.key[0]) === -1) {
                      keys.push(d.key[0]);
                  }
                  if (subKeys.indexOf(d.key[1]) === -1) {
                      subKeys.push(d.key[1]);
                  }
                  tmpObj[d.key[0]] = tmpObj[d.key[0]] || {};
                  tmpObj[d.key[0]][d.key[1]] = {
                      value: _chart.valueAccessor()(d),
                      order: d.key[3]
                  };
              });
  
        keys.map(function (key) {
            var group = {
                key: key,
                groupData: []
            };
  
            subKeys.map(function (subKey) {
                var item = tmpObj[key][subKey];
                group.groupData.push({
                    name: subKey,
                    value: item.value,
                    order: item.order
                });
            });
  
            group.groupData.sort(function (a, b) {
                if (a.order > b.order) {
                    return 1;
                } else if (a.order &lt; b.order) {
                    return -1;
                } else {
                    return 0;
                }
            });
  
            _data.push(group);
        });
  
        if (_chart.sortArray) {
            var result = [];
            _chart.sortArray.forEach(function (key) {
                var found = false;
                _data = _data.filter(function (item) {
                    if (!found &amp;&amp; item.key === key) {
                        result.push(item);
                        found = true;
                        return false;
                    } else {
                        return true;
                    }
                });
            });
  
            _data = result;
        }
  
        return _data;
    };
  
    _chart.data(function (group) {
        return _chart.parseGroup(group);
    });
  
    function getChartData () {
        _chartData = _chart.data();
        if (_chartData.length > 0) {
            _groupNames = _chartData[0]
                  .groupData.map(function (d) {
                      return d.name;
                  });
        }
    }
  
    _chart._doRender = function () {
        _chart.resetSvg();
        _g = _chart.svg();
        drawChart();
        return _chart;
    };
  
    _chart._doRedraw = function () {
        getChartData();
        updateValues();
        return _chart;
    };
  
    function calculateMinMax () {
        _yAxisMinValue = _yAxisMinValue || 0;
        _yAxisMaxValue = _yAxisMaxValue || 0;
  
        var min = d3.min(_chartData, function (d) {
            return d3.min(d.groupData, function (d) {
                return d.value;
            });
        });
  
        var max = d3.max(_chartData, function (d) {
            return d3.max(d.groupData, function (d) {
                return d.value;
            });
        });
  
        if (min > _yAxisMinValue) {
            min = _yAxisMinValue;
        }
  
        if (max &lt; _yAxisMaxValue) {
            max = _yAxisMaxValue;
        }
  
        return {
            min: min,
            max: max
        };
    }
  
    function updateValues () {
        var chartGroup2 = _chartArea.selectAll('.chartGroup')
              .data(_chartData);
  
        var domain = calculateMinMax();
  
        chartGroup2.selectAll('text')
              .data(function (d) {
                  return d.groupData;
              })
              .text(function (d) {
                  if (+d.value > 0) {
                      return _valueLabelFormat(+d.value);
                  } else {
                      return '';
                  }
              })
              .transition()
              .duration(_chart.transitionDuration())
              .attr('y', function (d) {
                  return _yScale(Math.max(0, d.value));
              })
              .style('fill', '#000000');
  
        chartGroup2.selectAll('rect')
              .data(function (d) {
                  return d.groupData;
              })
              .transition()
              .duration(_chart.transitionDuration())
              .attr('y', function (d) {
                  return _yScale(Math.max(0, d.value));
              })
              .attr('height', function (d) {
                  return Math.abs(_yScale(d.value - Math.max(0, domain.min)) - _yScale(0));
              });
  
        // move x-axis text to the bottom of the chart
        if (domain.min &lt; 0) {
            _chartArea
          .selectAll('.x.axis text')
          .attr('dy', _yScale(0));
        }
    }
  
    function drawChart () {
        _chartWidth = _chart.width() - _chart.margins().left - _chart.margins().right;
  
        _chartHeight = _chart.height() - _chart.margins().top - _chart.margins().bottom;
  
        // Data here
        getChartData();
  
        var domain = calculateMinMax();
  
        if (_chartData.length === 0) {
            return;
        }
  
        var x0 = d3.scale.ordinal()
              .rangeRoundBands([0, _chartWidth], 0.15);
  
        var x1 = d3.scale.ordinal();
  
        _yScale = d3.scale.linear()
              .range([_chartHeight, 0]);
  
        _chart.y = function () {
            return function (value) {
                return _yScale(value);
            };
        };
  
        var color = _colors;
  
        var xAxis = d3.svg.axis()
              .scale(x0)
              .orient('bottom');
  
        var yAxis = d3.svg.axis()
              .scale(_yScale)
              .orient('left')
              .tickFormat(_yAxisLabelFormat);
  
        _chartArea = _g
              .attr('width', _chart.width())
              .attr('height', _chart.height())
              .append('g')
              .attr('class', 'chart-body')
              .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');
  
        x0.domain(_chartData.map(function (d) {
            return d.key;
        }));
  
        x1.domain(_groupNames)
              .rangeRoundBands([0,
                                x0.rangeBand()
              ]);
  
        _yScale.domain([
            domain.min,
            domain.max
        ]);
  
        // X axis title
        _chartArea.append('g')
        .attr('class', 'x-axis-label x-label')
        .append('text')
        .attr('x', -_chart.margins().right + (_chartWidth / 2))
        .attr('y', _chartHeight + _chart.margins().bottom - 10)
        .text(_xAxisLabel);
  
        // Y axis title
        _chartArea.append('g')
        .attr('class', 'y-axis-label y-label')
        .append('text')
        .attr('x', -(_chartHeight / 2))
        .attr('y', -_chart.margins().left + 15)
        .attr('transform', 'rotate(-90)')
        .text(_yAxisLabel);
  
        // Add axis
        _chartArea.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + _yScale(Math.max(0, domain.min)) + ')')
        .call(xAxis);
  
        _chartArea.append('g')
        .attr('class', 'y axis')
        .call(yAxis)
        .append('text');
  
        // Add group bars
        var chartGroup = _chartArea.selectAll('.chartGroup')
        .data(_chartData)
        .enter()
        .append('g')
        .attr('class', 'chartGroup')
        .attr('transform', function (d) {
            return 'translate(' + x0(d.key) + ',0)';
        });
  
        chartGroup.selectAll('rect')
        .data(function (d) {
            for (var i = 0; i &lt; d.groupData.length; i++) {
                d.groupData[i].key = d.key;
            }
            return d.groupData;
        })
        .enter()
        .append('rect')
        .style('fill', function (d) {
            if (_highlightVariables.indexOf(d.key) !== -1) {
                return _highlightColor;
            } else {
                return color(d.name);
            }
        })
        .attr('width', x1.rangeBand())
        .attr('x', function (d) {
            return x1(d.name);
        })
        .append('title')
        .text(function (d) {
            return d.name + ': ' + d.value;
        });
        updateValues();
    }
  
    return _chart.anchor(parent, chartGroup);
};
  
/**
   * Concrete grouped row chart implementation.
   *
   * @name groupedRowChart
   * @param {String|node|d3.selection} parent - Any valid
   * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
   * @return {dc.groupedRowChart}
   */
dc.groupedRowChart = function (parent, chartGroup) {
    var _g;
  
    var _width = 100;
    var _height = 100;
  
    var _chartWidth = _width;
    var _chartHeight = _height;
  
    var _chart = dc.marginMixin(dc.baseMixin({}));
  
    // Set standard margins
    _chart.margins().top = 20;
    _chart.margins().right = 20;
    _chart.margins().bottom = 40;
    _chart.margins().left = 40;
  
    var _valueLabelFormat = d3.format(',.0f');
    var _xAxisLabelFormat = d3.format(',.0f');
    var _xAxisLabel;
    var _yAxisLabel;
    var _yAxisMinValue = 0;
    var _yAxisMaxValue;
    var _yScale1;
    var _yScale0;
    var _xAxis;
    var _yAxis;
    var _chartArea;
    var _chartData;
    var _colors;
    var _groupNames;
    var _xScale;
    var _highlightVariables = [];
    var _highlightColor = '#ff0000';
  
    var _seriesSort = function (d) {
        return d.name;
    };
  
    var _valueAccessor = function (d) {
        return d.value;
    };
  
    _chart.highlightVariables = function (highlightVariables) {
        _highlightVariables = highlightVariables;
        return _chart;
    };
  
    _chart.highlightColor = function (highlightColor) {
        _highlightColor = highlightColor;
        return _chart;
    };
  
    _chart.colors = function (colorScale) {
        if (typeof colorScale === 'function') {
            _colors = colorScale;
        }
        return _chart;
    };
  
    _chart.seriesSort = function (seriesSortFunction) {
        if (typeof seriesSortFunction === 'function') {
            _seriesSort = seriesSortFunction;
        } else {
            return _seriesSort;
        }
    };
  
    _chart.xAxisLabelFormat = function (d3FormatString) {
        if (d3FormatString !== undefined) {
            _xAxisLabelFormat = d3.format(d3FormatString);
        } else {
            return _xAxisLabelFormat;
        }
        return _chart;
    };
  
    _chart.valueLabelFormat = function (d3FormatString) {
        if (d3FormatString !== undefined) {
            _valueLabelFormat = d3.format(d3FormatString);
        } else {
            return _valueLabelFormat;
        }
        return _chart;
    };
  
    _chart.valueAccessor = function (valueAccessor) {
        if (valueAccessor === undefined) {
            return _valueAccessor;
        } else {
            _valueAccessor = valueAccessor;
        }
        return _chart;
    };
  
    _chart.width = function (width) {
        if (width === undefined) {
            return _width;
        } else {
            _width = width;
        }
        return _chart;
    };
  
    _chart.height = function (height) {
        if (height === undefined) {
            return _height;
        } else {
            _height = height;
        }
        return _chart;
    };
  
    _chart.xAxisLabel = function (title) {
        _xAxisLabel = title;
        return _chart;
    };
  
    _chart.yAxisLabel = function (title) {
        _yAxisLabel = title;
        return _chart;
    };
  
    _chart.yAxisMinValue = function (value) {
        if (value) {
            _yAxisMinValue = value;
        }
        return _chart;
    };
  
    _chart.yAxisMaxValue = function (value) {
        if (value) {
            _yAxisMaxValue = value;
        }
        return _chart;
    };
  
    _chart.parseGroup = function (inputGroup) {
        var tmpObj = {};
        var keys = [];
        var subKeys = [];
        var _data = [];
  
        inputGroup.all()
        .map(function (d) {
            if (keys.indexOf(d.key[0]) === -1) {
                keys.push(d.key[0]);
            }
            if (subKeys.indexOf(d.key[1]) === -1) {
                subKeys.push(d.key[1]);
            }
            tmpObj[d.key[0]] = tmpObj[d.key[0]] || {};
            tmpObj[d.key[0]][d.key[1]] = {
                value: _chart.valueAccessor()(d),
                order: d.key[3]
            };
        });
  
        keys.map(function (key) {
            var group = {
                key: key,
                groupData: []
            };
  
            subKeys.map(function (subKey) {
                var item = tmpObj[key][subKey];
                group.groupData.push({
                    name: subKey,
                    value: item.value,
                    order: item.order
                });
            });
  
            group.groupData.sort(function (a, b) {
                if (a.order > b.order) {
                    return 1;
                } else if (a.order &lt; b.order) {
                    return -1;
                } else {
                    return 0;
                }
            });
  
            _data.push(group);
        });
  
        if (_chart.sortArray) {
            var result = [];
            _chart.sortArray.forEach(function (key) {
                var found = false;
                _data = _data.filter(function (item) {
                    if (!found &amp;&amp; item.key === key) {
                        result.push(item);
                        found = true;
                        return false;
                    } else {
                        return true;
                    }
                });
            });
  
            _data = result;
        }
  
        return _data;
    };
  
    _chart.data(function (group) {
        return _chart.parseGroup(group);
    });
  
    _chart._doRender = function () {
        _chart.resetSvg();
        _g = _chart.svg();
        drawChart();
        return _chart;
    };
  
    _chart._doRedraw = function () {
        getChartData();
        updateValues();
        return _chart;
    };
  
    function calculateMinMax () {
        _yAxisMinValue = _yAxisMinValue || 0;
        _yAxisMaxValue = _yAxisMaxValue || 0;
  
        var min = d3.min(_chartData, function (d) {
            return d3.min(d.groupData, function (d) {
                return d.value;
            });
        });
  
        var max = d3.max(_chartData, function (d) {
            return d3.max(d.groupData, function (d) {
                return d.value;
            });
        });
  
        if (min > _yAxisMinValue) {
            min = _yAxisMinValue;
        }
  
        if (max &lt; _yAxisMaxValue) {
            max = _yAxisMaxValue;
        }
  
        return {
            min: min,
            max: max
        };
    } 
  
    function updateValues () {
        var chartGroup2 = _chartArea.selectAll('.chartGroup')
              .data(_chartData);
  
        var domain = calculateMinMax();
  
        chartGroup2.selectAll('text')
        .data(function (d) {
            return d.groupData;
        })
        .text(function (d) {
            if (+d.value > 0) {
                return _valueLabelFormat(+d.value);
            } else {
                return '';
            }
        })
        .transition()
        .duration(_chart.transitionDuration())
        .attr('x', function (d) {
            return _xScale(Math.min(0, d.value));
        })
        .style('fill', '#000000');
  
        chartGroup2.selectAll('rect')
        .data(function (d) {
            return d.groupData;
        })
        .attr('width', function (d) {
            return Math.abs(_xScale(d.value) - _xScale(Math.max(0, domain.min)));
        });
  
        // move y-axis text to the left of the chart
        if (domain.min &lt; 0) {
            _chartArea
          .selectAll('.y.axis text')
          .attr('dx', -_xScale(0));
        }
    }
  
    function getChartData () {
        _chartData = _chart.data();
        if (_chartData.length > 0) {
            _groupNames = _chartData[0]
                  .groupData.map(function (d) {
                      return d.name;
                  });
        }
    }
  
    function drawChart () {
        _chartWidth = _chart.width() - _chart.margins().left - _chart.margins().right;
  
        _chartHeight = _chart.height() - _chart.margins().top - _chart.margins().bottom;
  
        _yScale0 = d3.scale.ordinal()
        .rangeRoundBands([0, _chartHeight], 0.15);
  
        _yScale1 = d3.scale.ordinal();
  
        _xScale = d3.scale.linear()
        .range([0, _chartWidth]);
  
        _xAxis = d3.svg.axis()
        .scale(_xScale)
        .orient('bottom')
        .tickFormat(_xAxisLabelFormat);
  
        _yAxis = d3.svg.axis()
        .scale(_yScale0)
        .orient('left');
  
        _chartArea = _g
        .attr('width', _chart.width())
        .attr('height', _chart.height())
        .append('g')
        .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');
  
        // Data here
        getChartData();
  
        var domain = calculateMinMax();
  
        if (_chartData.length === 0) {
            return;
        }
  
        _yScale0.domain(_chartData.map(function (d) {
            return d.key;
        }));
  
        _yScale1.domain(_groupNames)
        .rangeRoundBands([0,
                          _yScale0.rangeBand()
        ]);
  
        _xScale.domain([
            domain.min,
            domain.max
        ]);
  
        // X axis title
        _chartArea.append('g')
        .attr('class', 'x-axis-label x-label')
        .append('text')
        .attr('x', -_chart.margins().right + (_chartWidth / 2))
        .attr('y', _chartHeight + _chart.margins().bottom - 10)
        .text(_xAxisLabel);
  
        // Y axis title
        _chartArea.append('g')
        .attr('class', 'y-axis-label y-label')
        .append('text')
        .attr('x', -(_chartHeight / 2))
        .attr('y', -_chart.margins().left + 15)
        .attr('transform', 'rotate(-90)')
        .text(_yAxisLabel);
  
        // Add axis
        _chartArea.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + _chartHeight + ')')
        .call(_xAxis);
  
        _chartArea.append('g')
        .attr('class', 'y axis')
        .attr('transform', 'translate(' + _xScale(Math.max(0, domain.min)) + ',0)')
        .call(_yAxis)
        .selectAll('text')
        .attr('dy', '0em')
        .attr('transform', 'rotate(-90)')
        .style('text-anchor', 'end');
  
        // Add group bars
        var chartGroup = _chartArea.selectAll('.chartGroup')
        .data(_chartData)
        .enter()
        .append('g')
        .attr('class', 'chartGroup')
        .attr('transform', function (d) {
            return 'translate(0, ' + _yScale0(d.key) + ')';
        });
  
        chartGroup.selectAll('rect')
        .data(function (d) {
            for (var i = 0; i &lt; d.groupData.length; i++) {
                d.groupData[i].key = d.key;
            }
            return d.groupData;
        })
        .enter()
        .append('rect')
        .style('fill', function (d) {
            if (_highlightVariables.indexOf(d.key) !== -1) {
                return _highlightColor;
            } else {
                return _colors(d.name);
            }
        })
        .attr('height', _yScale1.rangeBand())
        .attr('y', function (d) {
            return _yScale1(d.name);
        })
        .attr('width', function (d) {
            return 0;
        })
        .attr('x', function (d) {
            return _xScale(Math.min(0, d.value) + Math.max(0, domain.min));
        })
        .append('title')
        .text(function (d) {
            return d.name + ': ' + d.value;
        });
        updateValues();
    }
  
    return _chart.anchor(parent, chartGroup);
};
  
/**
   * Stacked grouped row chart implementation.
   *
   * @name groupedRowChart
   * @param {String|node|d3.selection} parent - Any valid
   * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
   * @return {dc.groupedRowChart}
   */
dc.groupedStackedRowChart = function (parent, chartGroup) {
    var _chart = dc.marginMixin(dc.baseMixin({ animation: false }));
    var _g;
    var xScale;
    var yScale;
    var _xAxisLabel;
    var _yAxisLabel;
    var _colors;
  
    // Set standard margins
    _chart.margins().top = 20;
    _chart.margins().right = 20;
    _chart.margins().bottom = 40;
    _chart.margins().left = 40;
  
    var buildOut = function () {
        var offsets = {};
        return function (d, y0, y) {
            var current = offsets[d.x];
            if (!current) {
                current = [0, 0];
            }
            if (y >= 0) {
                d.y0 = current[0];
                d.y = y;
                current[0] += y;
            } else {
                d.y0 = current[1] + y;
                d.y = y;
                current[1] += y;
            }
  
            offsets[d.x] = current;
        };
    };
  
    _chart.colors = function (colors) {
        _colors = colors;
        return _chart;
    };
  
    _chart.xAxisLabel = function (title) {
        _xAxisLabel = title;
        return _chart;
    };
  
    _chart.yAxisLabel = function (title) {
        _yAxisLabel = title;
        return _chart;
    };
  
    _chart.data(function (group) {
        var dataset = group.map(function (d) {
            return d.key[1].map(function (o, i) {
                // Structure it so that your numeric
                // axis (the stacked amount) is y
                return {
                    x: o.title,
                    y: o.value,
                    z: d.key[0]
                };
            });
        });
        var stack = d3.layout.stack().out(buildOut());
  
        stack(dataset);
  
        dataset = dataset.map(function (group) {
            return group.map(function (d) {
                // Invert the x and y values, and y0 becomes x0
                return {
                    x: d.y,
                    y: d.x,
                    x0: d.y0,
                    z: d.z
                };
            });
        });
  
        return dataset;
    });
  
    _chart.label(function (d) {
        return dc.utils.printSingleValue(d.x0 + d.x);
    }, false);
  
    _chart._doRender = function () {
        _chart.resetSvg();
        _g = _chart.svg();
        drawChart();
        return _chart;
    };
  
    _chart._doRedraw = function () {
        var data = _chart.data();
        updateValues(data);
        return _chart;
    };
  
    function updateValues (_chartData) {
        _g.selectAll('rect')
        .transition()
        .duration(_chart.transitionDuration())
        .attr('x', function (d) {
            return xScale(d.x0);
        })
        .attr('width', function (d) {
            return Math.abs(xScale(d.x) - xScale(0));
        });
  
        // move y-axis text to the bottom of the chart
        _g
        .selectAll('.y.axis text')
        .attr('dx', -xScale(0));
    }
  
    function drawChart () {
        // Get your data
        var data = _chart.data();
        var margins = _chart.margins();
        var height = _chart.height();
        var width = _chart.width();
        var _colorScale = _colors;
        var _chartWidth = _chart.width() - _chart.margins().left - _chart.margins().right;
        var _chartHeight = _chart.height() - _chart.margins().top - _chart.margins().bottom;
  
        _chart.title(function (d) {
            return d.z;
        });
  
        // Put all drawing methods here
        var _chartArea = _g
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', 'translate(' + margins.left + ',' + margins.top + ')');
  
        var xMin = d3.min(data, function (group) {
            return d3.min(group, function (d) {
                return d.x0;
            });
        });
        var xMax = d3.max(data, function (group) {
            return d3.max(group, function (d) {
                return d.x + d.x0;
            });
        });
        var domain = data[0].map(function (d) {
            return d.y;
        });
  
        xScale = d3.scale.linear()
                  .domain([xMin, xMax])
                  .range([0, width - margins.left - margins.right]);
        yScale = d3.scale.ordinal()
                  .domain(domain)
                  .rangeRoundBands([0, height - margins.top - margins.bottom], 0.1);
  
        var xAxis = d3.svg.axis()
        .scale(xScale)
        .orient('bottom');
  
        var yAxis = d3.svg.axis()
        .scale(yScale)
        .orient('left');
  
        var chartGroup = _chartArea.selectAll('.chartGroup')
        .data(data)
        .enter()
        .append('g');
  
        chartGroup.selectAll('rect')
        .data(function (d) {
            return d;
        })
        .enter()
        .append('rect')
        .style('fill', function (d) {
            return _colorScale(d.z);
        })
        .attr('x', function (d) {
            return 0;
        })
            .attr('y', function (d, i) {
                return yScale(d.y);
            })
            .attr('height', function (d) {
                return yScale.rangeBand();
            })
            .attr('width', function (d) {
                return 0;
            })
        .append('svg:title').text(function (d) {
            return d.z + ': ' + d.x;
        });
  
        // X axis title
        _chartArea.append('g')
        .attr('class', 'x-axis-label x-label')
        .append('text')
        .attr('x', -_chart.margins().right + (_chartWidth / 2))
        .attr('y', _chartHeight + _chart.margins().bottom - 10)
        .text(_xAxisLabel);
  
        // Y axis title
        _chartArea.append('g')
        .attr('class', 'y-axis-label y-label')
        .append('text')
        .attr('x', -(_chartHeight / 2))
        .attr('y', -_chart.margins().left + 15)
        .attr('transform', 'rotate(-90)')
        .text(_yAxisLabel);
  
        // Add axis
        _chartArea.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + (height - margins.top - margins.bottom) + ')')
        .call(xAxis);
  
        _chartArea.append('g')
        .attr('class', 'y axis')
        .attr('transform', 'translate(' + xScale(0) + ',0)')
        .call(yAxis)
        .selectAll('text')
        .attr('dy', '0em')
        .style('text-anchor', 'end');
  
        updateValues(data);
    }
  
    return _chart.anchor(parent, chartGroup);
};
  
dc.stackedRowChart = function (parent, chartGroup) {
    var _chart = dc.marginMixin(dc.baseMixin({}));
    var _g;
  
    // Set standard margins
    _chart.margins().top = 20;
    _chart.margins().right = 20;
    _chart.margins().bottom = 40;
    _chart.margins().left = 40;
  
    var buildOut = function () {
        var offsets = {};
        return function (d, y0, y) {
            var current = offsets[d.x];
            if (!current) {
                current = [0, 0];
            }
            if (y >= 0) {
                d.y0 = current[0];
                d.y = y;
                current[0] += y;
            } else {
                d.y0 = current[1] + y;
                d.y = y;
                current[1] += y;
            }
  
            offsets[d.x] = current;
        };
    };
  
    _chart.data(function (group) {
        // Do this first: Make copy of group data array
        var tmpData = group.all().slice();
  
        var dataset = tmpData.map(function (d) {
            return d.key[1].map(function (o, i) {
                // Structure it so that your numeric
                // axis (the stacked amount) is y
                return {
                    x: o.title,
                    y: o.value,
                    z: d.key[0]
                };
            });
        });
        var stack = d3.layout.stack().out(buildOut());
  
        stack(dataset);
  
        dataset = dataset.map(function (group) {
            return group.map(function (d) {
                // Invert the x and y values, and y0 becomes x0
                return {
                    x: d.y,
                    y: d.x,
                    x0: d.y0,
                    z: d.z
                };
            });
        });
  
        return dataset;
    });
  
    _chart._doRender = function () {
        _chart.resetSvg();
        _g = _chart.svg();
        drawChart();
        return _chart;
    };
  
    _chart._doRedraw = function () {
        return _chart;
    };
  
    function drawChart () {
        // Get your data
        var data = _chart.data();
        var height = _chart.height();
        var width = _chart.width();
  
        // Put all drawing methods here
        var _chartArea = _g
        .attr('width', _chart.width())
        .attr('height', _chart.height())
        .append('g')
        .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');
  
        var xMax = d3.max(data, function (group) {
            return d3.max(group, function (d) {
                return d.x + d.x0;
            });
        });
        var xScale = d3.scale.linear()
        .domain([0, xMax])
        .range([0, width]);
        var domain = data[0].map(function (d) {
            return d.y;
        });
        var yScale = d3.scale.ordinal()
        .domain(domain)
        .rangeRoundBands([0, height], 0.1);
        var xAxis = d3.svg.axis()
        .scale(xScale)
        .orient('bottom');
        var yAxis = d3.svg.axis()
        .scale(yScale)
        .orient('left');
        var colours = d3.scale.category10();
        var groups = _chartArea.selectAll('g')
        .data(data)
        .enter()
        .append('g')
        .style('fill', function (d, i) {
            return colours(i);
        });
        groups.selectAll('rect')
        .data(function (d) {
            return d;
        })
        .enter()
        .append('rect')
        .attr('x', function (d) {
            return xScale(d.x0);
        })
        .attr('y', function (d, i) {
            return yScale(d.y);
        })
        .attr('height', function (d) {
            return yScale.rangeBand();
        })
        .attr('width', function (d) {
            return xScale(d.x);
        })
        .on('mouseover', function (d) {
            var xPos = parseFloat(d3.select(this).attr('x')) / 2 + width / 2;
            var yPos = parseFloat(d3.select(this).attr('y')) + yScale.rangeBand() / 2;
  
            d3.select('#tooltip')
            .style('left', xPos + 'px')
            .style('top', yPos + 'px')
            .select('#value')
            .text(d.x);
  
            d3.select('#tooltip').classed('hidden', false);
        })
        .on('mouseout', function () {
            d3.select('#tooltip').classed('hidden', true);
        });
  
        _chartArea.append('g')
                  .attr('class', 'axis')
                  .attr('transform', 'translate(0,' + height + ')')
                  .call(xAxis);
  
        _chartArea.append('g')
                  .attr('class', 'axis')
                  .call(yAxis);
    }
  
    return _chart.anchor(parent, chartGroup);
};</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	dc.js Copyright © 2012-2018 Nick Zhu & the dc.js Developers
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a>
	
		on Sat Jun 29th 2019
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
